-- =====================================================
-- PROCEDIMIENTOS ALMACENADOS
-- Sistema de Gestión de Proyectos - Maya Guatemala
-- =====================================================

-- =====================================================
-- PROCEDIMIENTOS PARA PROYECTOS
-- =====================================================

-- Función para calcular progreso de proyecto basado en fases
CREATE OR REPLACE FUNCTION sp_update_project_progress(p_project_id INTEGER)
RETURNS VOID AS $$
DECLARE
    avg_progress DECIMAL(5,2);
BEGIN
    SELECT COALESCE(AVG(progress_percentage), 0)
    INTO avg_progress
    FROM project_phases
    WHERE project_id = p_project_id;
    
    UPDATE projects
    SET progress_percentage = avg_progress,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_project_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_update_project_progress IS 'Actualiza el progreso del proyecto basado en el promedio de sus fases';

-- Función para obtener resumen de proyecto
CREATE OR REPLACE FUNCTION sp_get_project_summary(p_project_id INTEGER)
RETURNS TABLE (
    project_id INTEGER,
    project_name VARCHAR,
    project_code VARCHAR,
    status project_status,
    progress_percentage DECIMAL,
    estimated_budget DECIMAL,
    actual_budget DECIMAL,
    budget_executed DECIMAL,
    budget_remaining DECIMAL,
    execution_percentage DECIMAL,
    total_beneficiaries BIGINT,
    total_phases BIGINT,
    total_evidences BIGINT,
    total_invoices BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        p.project_name,
        p.project_code,
        p.status,
        p.progress_percentage,
        p.estimated_budget,
        p.actual_budget,
        COALESCE(SUM(be.total_amount), 0) AS budget_executed,
        p.estimated_budget - COALESCE(SUM(be.total_amount), 0) AS budget_remaining,
        CASE 
            WHEN p.estimated_budget > 0 THEN 
                ROUND((COALESCE(SUM(be.total_amount), 0) / p.estimated_budget * 100), 2)
            ELSE 0 
        END AS execution_percentage,
        COUNT(DISTINCT pb.beneficiary_id) AS total_beneficiaries,
        COUNT(DISTINCT pp.id) AS total_phases,
        COUNT(DISTINCT pe.id) AS total_evidences,
        COUNT(DISTINCT be.id) AS total_invoices
    FROM projects p
    LEFT JOIN project_beneficiaries pb ON p.id = pb.project_id
    LEFT JOIN project_phases pp ON p.id = pp.project_id
    LEFT JOIN project_evidences pe ON p.id = pe.project_id
    LEFT JOIN budget_execution be ON p.id = be.project_id AND be.is_approved = TRUE
    WHERE p.id = p_project_id
    GROUP BY p.id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_get_project_summary IS 'Obtiene un resumen completo de un proyecto';

-- Función para crear proyecto con fases
CREATE OR REPLACE FUNCTION sp_create_project_with_phases(
    p_project_name VARCHAR,
    p_project_code VARCHAR,
    p_description TEXT,
    p_objectives TEXT,
    p_what_is_done TEXT,
    p_department VARCHAR,
    p_municipality VARCHAR,
    p_location VARCHAR,
    p_start_date DATE,
    p_end_date DATE,
    p_estimated_budget DECIMAL,
    p_cover_image_url TEXT,
    p_responsible_user INTEGER,
    p_created_by INTEGER,
    p_phases JSONB  -- Array de fases: [{"phase_name": "Fase 1", "description": "...", ...}]
)
RETURNS INTEGER AS $$
DECLARE
    v_project_id INTEGER;
    v_phase JSONB;
    v_phase_number INTEGER := 1;
    v_has_phases BOOLEAN := FALSE;
BEGIN
    -- Determinar si tiene fases
    IF p_phases IS NOT NULL AND jsonb_array_length(p_phases) > 0 THEN
        v_has_phases := TRUE;
    END IF;
    
    -- Insertar proyecto
    INSERT INTO projects (
        project_name, project_code, description, objectives, what_is_done,
        department, municipality, location, start_date, end_date, estimated_budget,
        cover_image_url, has_phases, responsible_user, created_by
    ) VALUES (
        p_project_name, p_project_code, p_description, p_objectives, p_what_is_done,
        p_department, p_municipality, p_location, p_start_date, p_end_date, p_estimated_budget,
        p_cover_image_url, v_has_phases, p_responsible_user, p_created_by
    ) RETURNING id INTO v_project_id;
    
    -- Insertar fases si existen
    IF v_has_phases THEN
        FOR v_phase IN SELECT * FROM jsonb_array_elements(p_phases)
        LOOP
            INSERT INTO project_phases (
                project_id, phase_name, phase_number, description,
                start_date, end_date, estimated_budget, created_by
            ) VALUES (
                v_project_id,
                v_phase->>'phase_name',
                v_phase_number,
                v_phase->>'description',
                (v_phase->>'start_date')::DATE,
                (v_phase->>'end_date')::DATE,
                (v_phase->>'estimated_budget')::DECIMAL,
                p_created_by
            );
            v_phase_number := v_phase_number + 1;
        END LOOP;
    END IF;
    
    RETURN v_project_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_create_project_with_phases IS 'Crea un proyecto con sus fases en una sola transacción';

-- =====================================================
-- PROCEDIMIENTOS PARA BENEFICIARIOS
-- =====================================================

-- Función para crear beneficiario completo
CREATE OR REPLACE FUNCTION sp_create_complete_beneficiary(
    -- Datos principales
    p_first_name VARCHAR,
    p_last_name VARCHAR,
    p_cui_dpi VARCHAR,
    p_department VARCHAR,
    p_municipality VARCHAR,
    p_birth_date DATE,
    p_gender VARCHAR,
    p_created_by INTEGER,
    -- Datos de salud (JSONB)
    p_health_data JSONB DEFAULT NULL,
    -- Datos de educación (JSONB)
    p_education_data JSONB DEFAULT NULL,
    -- Datos de vivienda (JSONB)
    p_housing_data JSONB DEFAULT NULL,
    -- Datos económicos (JSONB)
    p_economy_data JSONB DEFAULT NULL
)
RETURNS INTEGER AS $$
DECLARE
    v_beneficiary_id INTEGER;
    v_age INTEGER;
BEGIN
    -- Calcular edad
    v_age := EXTRACT(YEAR FROM AGE(CURRENT_DATE, p_birth_date));
    
    -- Insertar beneficiario principal
    INSERT INTO beneficiaries (
        first_name, last_name, cui_dpi, department, municipality,
        birth_date, age, gender, created_by
    ) VALUES (
        p_first_name, p_last_name, p_cui_dpi, p_department, p_municipality,
        p_birth_date, v_age, p_gender, p_created_by
    ) RETURNING id INTO v_beneficiary_id;
    
    -- Insertar datos de salud si existen
    IF p_health_data IS NOT NULL THEN
        INSERT INTO beneficiary_health (
            beneficiary_id, is_pregnant, is_breastfeeding,
            has_diabetes, has_high_blood_pressure, has_low_blood_pressure
        ) VALUES (
            v_beneficiary_id,
            COALESCE((p_health_data->>'is_pregnant')::BOOLEAN, FALSE),
            COALESCE((p_health_data->>'is_breastfeeding')::BOOLEAN, FALSE),
            COALESCE((p_health_data->>'has_diabetes')::BOOLEAN, FALSE),
            COALESCE((p_health_data->>'has_high_blood_pressure')::BOOLEAN, FALSE),
            COALESCE((p_health_data->>'has_low_blood_pressure')::BOOLEAN, FALSE)
        );
    ELSE
        INSERT INTO beneficiary_health (beneficiary_id) VALUES (v_beneficiary_id);
    END IF;
    
    -- Insertar datos de educación si existen
    IF p_education_data IS NOT NULL THEN
        INSERT INTO beneficiary_education (
            beneficiary_id, education_level, school_attendance,
            has_cellphone, has_computer, has_internet
        ) VALUES (
            v_beneficiary_id,
            (p_education_data->>'education_level')::education_level,
            (p_education_data->>'school_attendance')::school_attendance,
            COALESCE((p_education_data->>'has_cellphone')::BOOLEAN, FALSE),
            COALESCE((p_education_data->>'has_computer')::BOOLEAN, FALSE),
            COALESCE((p_education_data->>'has_internet')::BOOLEAN, FALSE)
        );
    ELSE
        INSERT INTO beneficiary_education (beneficiary_id) VALUES (v_beneficiary_id);
    END IF;
    
    -- Insertar datos de vivienda si existen
    IF p_housing_data IS NOT NULL THEN
        INSERT INTO beneficiary_housing (
            beneficiary_id, housing_tenure, housing_type,
            has_electricity, has_piped_water, has_sewage
        ) VALUES (
            v_beneficiary_id,
            (p_housing_data->>'housing_tenure')::housing_tenure,
            (p_housing_data->>'housing_type')::housing_type,
            COALESCE((p_housing_data->>'has_electricity')::BOOLEAN, FALSE),
            COALESCE((p_housing_data->>'has_piped_water')::BOOLEAN, FALSE),
            COALESCE((p_housing_data->>'has_sewage')::BOOLEAN, FALSE)
        );
    ELSE
        INSERT INTO beneficiary_housing (beneficiary_id) VALUES (v_beneficiary_id);
    END IF;
    
    -- Insertar datos económicos si existen
    IF p_economy_data IS NOT NULL THEN
        INSERT INTO beneficiary_economy (
            beneficiary_id, economically_active_employed,
            monthly_income, receives_social_aid
        ) VALUES (
            v_beneficiary_id,
            COALESCE((p_economy_data->>'economically_active_employed')::BOOLEAN, FALSE),
            (p_economy_data->>'monthly_income')::DECIMAL,
            COALESCE((p_economy_data->>'receives_social_aid')::BOOLEAN, FALSE)
        );
    ELSE
        INSERT INTO beneficiary_economy (beneficiary_id) VALUES (v_beneficiary_id);
    END IF;
    
    RETURN v_beneficiary_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_create_complete_beneficiary IS 'Crea un beneficiario con todos sus datos relacionados';

-- Función para obtener perfil completo del beneficiario
CREATE OR REPLACE FUNCTION sp_get_beneficiary_profile(p_beneficiary_id INTEGER)
RETURNS TABLE (
    beneficiary_id INTEGER,
    full_name VARCHAR,
    cui_dpi VARCHAR,
    dpi_image_url TEXT,
    birth_date DATE,
    age INTEGER,
    gender VARCHAR,
    department VARCHAR,
    municipality VARCHAR,
    health_data JSONB,
    education_data JSONB,
    housing_data JSONB,
    economy_data JSONB,
    projects_count BIGINT,
    phases_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        b.id,
        b.first_name || ' ' || b.last_name AS full_name,
        b.cui_dpi,
        b.dpi_image_url,
        b.birth_date,
        b.age,
        b.gender,
        b.department,
        b.municipality,
        jsonb_build_object(
            'is_pregnant', bh.is_pregnant,
            'is_breastfeeding', bh.is_breastfeeding,
            'has_diabetes', bh.has_diabetes,
            'has_high_blood_pressure', bh.has_high_blood_pressure,
            'has_any_disability', (bh.has_language_disability OR bh.has_hearing_disability OR 
                bh.has_visual_disability OR bh.has_physical_disability OR 
                bh.has_intellectual_disability OR bh.has_psychosocial_disability)
        ) AS health_data,
        jsonb_build_object(
            'education_level', be.education_level,
            'school_attendance', be.school_attendance,
            'has_cellphone', be.has_cellphone,
            'has_computer', be.has_computer,
            'has_internet', be.has_internet
        ) AS education_data,
        jsonb_build_object(
            'housing_tenure', bho.housing_tenure,
            'housing_type', bho.housing_type,
            'has_electricity', bho.has_electricity,
            'has_piped_water', bho.has_piped_water
        ) AS housing_data,
        jsonb_build_object(
            'is_employed', (bec.economically_active_employed OR bec.economically_active_independent OR 
                bec.economically_active_entrepreneur OR bec.economically_active_day_laborer),
            'monthly_income', bec.monthly_income,
            'receives_social_aid', bec.receives_social_aid
        ) AS economy_data,
        COUNT(DISTINCT pb.project_id) AS projects_count,
        COUNT(DISTINCT phb.phase_id) AS phases_count
    FROM beneficiaries b
    LEFT JOIN beneficiary_health bh ON b.id = bh.beneficiary_id
    LEFT JOIN beneficiary_education be ON b.id = be.beneficiary_id
    LEFT JOIN beneficiary_housing bho ON b.id = bho.beneficiary_id
    LEFT JOIN beneficiary_economy bec ON b.id = bec.beneficiary_id
    LEFT JOIN project_beneficiaries pb ON b.id = pb.beneficiary_id
    LEFT JOIN phase_beneficiaries phb ON b.id = phb.beneficiary_id
    WHERE b.id = p_beneficiary_id
    GROUP BY b.id, bh.is_pregnant, bh.is_breastfeeding, bh.has_diabetes, bh.has_high_blood_pressure,
        bh.has_language_disability, bh.has_hearing_disability, bh.has_visual_disability,
        bh.has_physical_disability, bh.has_intellectual_disability, bh.has_psychosocial_disability,
        be.education_level, be.school_attendance, be.has_cellphone, be.has_computer, be.has_internet,
        bho.housing_tenure, bho.housing_type, bho.has_electricity, bho.has_piped_water,
        bec.economically_active_employed, bec.economically_active_independent,
        bec.economically_active_entrepreneur, bec.economically_active_day_laborer,
        bec.monthly_income, bec.receives_social_aid;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_get_beneficiary_profile IS 'Obtiene el perfil completo de un beneficiario con todos sus datos';

-- =====================================================
-- PROCEDIMIENTOS PARA EVIDENCIAS
-- =====================================================

-- Función para crear evidencia de proyecto con fotos y beneficiarios
CREATE OR REPLACE FUNCTION sp_create_project_evidence(
    p_project_id INTEGER,
    p_start_date DATE,
    p_end_date DATE,
    p_description TEXT,
    p_requirements JSONB,
    p_photos JSONB,  -- Array de URLs: [{"photo_url": "...", "caption": "..."}]
    p_beneficiaries INTEGER[],  -- Array de IDs de beneficiarios
    p_created_by INTEGER
)
RETURNS INTEGER AS $$
DECLARE
    v_evidence_id INTEGER;
    v_photo JSONB;
    v_photo_order INTEGER := 1;
    v_beneficiary_id INTEGER;
BEGIN
    -- Crear evidencia
    INSERT INTO project_evidences (
        project_id, start_date, end_date, description, requirements, created_by
    ) VALUES (
        p_project_id, p_start_date, p_end_date, p_description, p_requirements, p_created_by
    ) RETURNING id INTO v_evidence_id;
    
    -- Agregar fotos si existen
    IF p_photos IS NOT NULL THEN
        FOR v_photo IN SELECT * FROM jsonb_array_elements(p_photos)
        LOOP
            INSERT INTO evidence_photos (
                evidence_id, photo_url, caption, photo_order, uploaded_by
            ) VALUES (
                v_evidence_id,
                v_photo->>'photo_url',
                v_photo->>'caption',
                v_photo_order,
                p_created_by
            );
            v_photo_order := v_photo_order + 1;
        END LOOP;
    END IF;
    
    -- Agregar beneficiarios si existen
    IF p_beneficiaries IS NOT NULL THEN
        FOREACH v_beneficiary_id IN ARRAY p_beneficiaries
        LOOP
            INSERT INTO evidence_beneficiaries (evidence_id, beneficiary_id)
            VALUES (v_evidence_id, v_beneficiary_id)
            ON CONFLICT (evidence_id, beneficiary_id) DO NOTHING;
        END LOOP;
    END IF;
    
    RETURN v_evidence_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_create_project_evidence IS 'Crea una evidencia de proyecto con fotos y beneficiarios asociados';

-- Función para crear evidencia de fase con fotos y beneficiarios
CREATE OR REPLACE FUNCTION sp_create_phase_evidence(
    p_phase_id INTEGER,
    p_start_date DATE,
    p_end_date DATE,
    p_description TEXT,
    p_requirements JSONB,
    p_photos JSONB,  -- Array de URLs: [{"photo_url": "...", "caption": "..."}]
    p_beneficiaries INTEGER[],  -- Array de IDs de beneficiarios
    p_created_by INTEGER
)
RETURNS INTEGER AS $$
DECLARE
    v_evidence_id INTEGER;
    v_photo JSONB;
    v_photo_order INTEGER := 1;
    v_beneficiary_id INTEGER;
BEGIN
    -- Crear evidencia
    INSERT INTO phase_evidences (
        phase_id, start_date, end_date, description, requirements, created_by
    ) VALUES (
        p_phase_id, p_start_date, p_end_date, p_description, p_requirements, p_created_by
    ) RETURNING id INTO v_evidence_id;
    
    -- Agregar fotos si existen
    IF p_photos IS NOT NULL THEN
        FOR v_photo IN SELECT * FROM jsonb_array_elements(p_photos)
        LOOP
            INSERT INTO phase_evidence_photos (
                phase_evidence_id, photo_url, caption, photo_order, uploaded_by
            ) VALUES (
                v_evidence_id,
                v_photo->>'photo_url',
                v_photo->>'caption',
                v_photo_order,
                p_created_by
            );
            v_photo_order := v_photo_order + 1;
        END LOOP;
    END IF;
    
    -- Agregar beneficiarios si existen
    IF p_beneficiaries IS NOT NULL THEN
        FOREACH v_beneficiary_id IN ARRAY p_beneficiaries
        LOOP
            INSERT INTO phase_evidence_beneficiaries (phase_evidence_id, beneficiary_id)
            VALUES (v_evidence_id, v_beneficiary_id)
            ON CONFLICT (phase_evidence_id, beneficiary_id) DO NOTHING;
        END LOOP;
    END IF;
    
    RETURN v_evidence_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_create_phase_evidence IS 'Crea una evidencia de fase con fotos y beneficiarios asociados';

-- Función para obtener evidencias de proyecto con detalles
CREATE OR REPLACE FUNCTION sp_get_project_evidences(p_project_id INTEGER)
RETURNS TABLE (
    evidence_id INTEGER,
    start_date DATE,
    end_date DATE,
    description TEXT,
    requirements JSONB,
    photos_count BIGINT,
    beneficiaries_count BIGINT,
    created_by_name VARCHAR,
    created_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pe.id,
        pe.start_date,
        pe.end_date,
        pe.description,
        pe.requirements,
        COUNT(DISTINCT ep.id) AS photos_count,
        COUNT(DISTINCT eb.beneficiary_id) AS beneficiaries_count,
        u.full_name AS created_by_name,
        pe.created_at
    FROM project_evidences pe
    LEFT JOIN evidence_photos ep ON pe.id = ep.evidence_id
    LEFT JOIN evidence_beneficiaries eb ON pe.id = eb.evidence_id
    LEFT JOIN users u ON pe.created_by = u.id
    WHERE pe.project_id = p_project_id
    GROUP BY pe.id, u.full_name
    ORDER BY pe.start_date DESC;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_get_project_evidences IS 'Obtiene todas las evidencias de un proyecto con conteos';

-- =====================================================
-- PROCEDIMIENTOS PARA EJECUCIÓN PRESUPUESTARIA
-- =====================================================

-- Función para crear factura de proyecto
CREATE OR REPLACE FUNCTION sp_create_project_invoice(
    p_project_id INTEGER,
    p_invoice_type invoice_type,
    p_invoice_number VARCHAR,
    p_invoice_date DATE,
    p_invoice_name VARCHAR,
    p_quantity DECIMAL,
    p_unit_price DECIMAL,
    p_tax_amount DECIMAL,
    p_description TEXT,
    p_category VARCHAR,
    p_supplier_name VARCHAR,
    p_invoice_document_url TEXT,
    p_created_by INTEGER
)
RETURNS INTEGER AS $$
DECLARE
    v_invoice_id INTEGER;
BEGIN
    INSERT INTO budget_execution (
        project_id, invoice_type, invoice_number, invoice_date, invoice_name,
        quantity, unit_price, tax_amount, description, category,
        supplier_name, invoice_document_url, created_by
    ) VALUES (
        p_project_id, p_invoice_type, p_invoice_number, p_invoice_date, p_invoice_name,
        p_quantity, p_unit_price, p_tax_amount, p_description, p_category,
        p_supplier_name, p_invoice_document_url, p_created_by
    ) RETURNING id INTO v_invoice_id;
    
    RETURN v_invoice_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_create_project_invoice IS 'Crea una factura asociada a un proyecto';

-- Función para crear factura de fase
CREATE OR REPLACE FUNCTION sp_create_phase_invoice(
    p_phase_id INTEGER,
    p_invoice_type invoice_type,
    p_invoice_number VARCHAR,
    p_invoice_date DATE,
    p_invoice_name VARCHAR,
    p_quantity DECIMAL,
    p_unit_price DECIMAL,
    p_tax_amount DECIMAL,
    p_description TEXT,
    p_category VARCHAR,
    p_supplier_name VARCHAR,
    p_invoice_document_url TEXT,
    p_created_by INTEGER
)
RETURNS INTEGER AS $$
DECLARE
    v_invoice_id INTEGER;
BEGIN
    INSERT INTO budget_execution (
        phase_id, invoice_type, invoice_number, invoice_date, invoice_name,
        quantity, unit_price, tax_amount, description, category,
        supplier_name, invoice_document_url, created_by
    ) VALUES (
        p_phase_id, p_invoice_type, p_invoice_number, p_invoice_date, p_invoice_name,
        p_quantity, p_unit_price, p_tax_amount, p_description, p_category,
        p_supplier_name, p_invoice_document_url, p_created_by
    ) RETURNING id INTO v_invoice_id;
    
    RETURN v_invoice_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_create_phase_invoice IS 'Crea una factura asociada a una fase';

-- Función para aprobar factura
CREATE OR REPLACE FUNCTION sp_approve_invoice(
    p_invoice_id INTEGER,
    p_approved_by INTEGER
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE budget_execution
    SET is_approved = TRUE,
        approved_by = p_approved_by,
        approval_date = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_invoice_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_approve_invoice IS 'Aprueba una factura';

-- Función para marcar factura como pagada
CREATE OR REPLACE FUNCTION sp_mark_invoice_paid(
    p_invoice_id INTEGER,
    p_payment_date DATE,
    p_payment_method VARCHAR,
    p_payment_reference VARCHAR
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE budget_execution
    SET is_paid = TRUE,
        payment_date = p_payment_date,
        payment_method = p_payment_method,
        payment_reference = p_payment_reference,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_invoice_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_mark_invoice_paid IS 'Marca una factura como pagada';

-- Función para obtener resumen de ejecución presupuestaria de proyecto
CREATE OR REPLACE FUNCTION sp_get_project_budget_summary(p_project_id INTEGER)
RETURNS TABLE (
    estimated_budget DECIMAL,
    total_executed DECIMAL,
    total_approved DECIMAL,
    total_paid DECIMAL,
    total_pending_approval DECIMAL,
    total_pending_payment DECIMAL,
    execution_percentage DECIMAL,
    total_invoices BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.estimated_budget,
        COALESCE(SUM(be.total_amount), 0) AS total_executed,
        COALESCE(SUM(CASE WHEN be.is_approved THEN be.total_amount ELSE 0 END), 0) AS total_approved,
        COALESCE(SUM(CASE WHEN be.is_paid THEN be.total_amount ELSE 0 END), 0) AS total_paid,
        COALESCE(SUM(CASE WHEN NOT be.is_approved THEN be.total_amount ELSE 0 END), 0) AS total_pending_approval,
        COALESCE(SUM(CASE WHEN be.is_approved AND NOT be.is_paid THEN be.total_amount ELSE 0 END), 0) AS total_pending_payment,
        CASE 
            WHEN p.estimated_budget > 0 THEN 
                ROUND((COALESCE(SUM(CASE WHEN be.is_approved THEN be.total_amount ELSE 0 END), 0) / p.estimated_budget * 100), 2)
            ELSE 0 
        END AS execution_percentage,
        COUNT(be.id) AS total_invoices
    FROM projects p
    LEFT JOIN budget_execution be ON p.id = be.project_id
    WHERE p.id = p_project_id
    GROUP BY p.id, p.estimated_budget;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_get_project_budget_summary IS 'Obtiene el resumen de ejecución presupuestaria de un proyecto';

-- Función para obtener resumen de ejecución presupuestaria de fase
CREATE OR REPLACE FUNCTION sp_get_phase_budget_summary(p_phase_id INTEGER)
RETURNS TABLE (
    estimated_budget DECIMAL,
    total_executed DECIMAL,
    total_approved DECIMAL,
    total_paid DECIMAL,
    total_pending_approval DECIMAL,
    total_pending_payment DECIMAL,
    execution_percentage DECIMAL,
    total_invoices BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pp.estimated_budget,
        COALESCE(SUM(be.total_amount), 0) AS total_executed,
        COALESCE(SUM(CASE WHEN be.is_approved THEN be.total_amount ELSE 0 END), 0) AS total_approved,
        COALESCE(SUM(CASE WHEN be.is_paid THEN be.total_amount ELSE 0 END), 0) AS total_paid,
        COALESCE(SUM(CASE WHEN NOT be.is_approved THEN be.total_amount ELSE 0 END), 0) AS total_pending_approval,
        COALESCE(SUM(CASE WHEN be.is_approved AND NOT be.is_paid THEN be.total_amount ELSE 0 END), 0) AS total_pending_payment,
        CASE 
            WHEN pp.estimated_budget > 0 THEN 
                ROUND((COALESCE(SUM(CASE WHEN be.is_approved THEN be.total_amount ELSE 0 END), 0) / pp.estimated_budget * 100), 2)
            ELSE 0 
        END AS execution_percentage,
        COUNT(be.id) AS total_invoices
    FROM project_phases pp
    LEFT JOIN budget_execution be ON pp.id = be.phase_id
    WHERE pp.id = p_phase_id
    GROUP BY pp.id, pp.estimated_budget;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_get_phase_budget_summary IS 'Obtiene el resumen de ejecución presupuestaria de una fase';

-- =====================================================
-- PROCEDIMIENTOS DE REPORTES Y ESTADÍSTICAS
-- =====================================================

-- Función para obtener estadísticas generales del sistema
CREATE OR REPLACE FUNCTION sp_get_system_statistics()
RETURNS TABLE (
    total_projects BIGINT,
    active_projects BIGINT,
    completed_projects BIGINT,
    total_beneficiaries BIGINT,
    active_beneficiaries BIGINT,
    total_phases BIGINT,
    total_evidences BIGINT,
    total_invoices BIGINT,
    total_budget_executed DECIMAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(DISTINCT p.id) AS total_projects,
        COUNT(DISTINCT CASE WHEN p.status IN ('en_progreso', 'planificado') THEN p.id END) AS active_projects,
        COUNT(DISTINCT CASE WHEN p.status = 'completado' THEN p.id END) AS completed_projects,
        COUNT(DISTINCT b.id) AS total_beneficiaries,
        COUNT(DISTINCT CASE WHEN b.is_active THEN b.id END) AS active_beneficiaries,
        COUNT(DISTINCT pp.id) AS total_phases,
        COUNT(DISTINCT pe.id) + COUNT(DISTINCT phe.id) AS total_evidences,
        COUNT(DISTINCT be.id) AS total_invoices,
        COALESCE(SUM(DISTINCT CASE WHEN be.is_approved THEN be.total_amount ELSE 0 END), 0) AS total_budget_executed
    FROM projects p
    CROSS JOIN beneficiaries b
    LEFT JOIN project_phases pp ON TRUE
    LEFT JOIN project_evidences pe ON TRUE
    LEFT JOIN phase_evidences phe ON TRUE
    LEFT JOIN budget_execution be ON TRUE;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_get_system_statistics IS 'Obtiene estadísticas generales del sistema';

-- Función para buscar beneficiarios
CREATE OR REPLACE FUNCTION sp_search_beneficiaries(
    p_search_term VARCHAR DEFAULT NULL,
    p_department VARCHAR DEFAULT NULL,
    p_municipality VARCHAR DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT TRUE
)
RETURNS TABLE (
    beneficiary_id INTEGER,
    full_name VARCHAR,
    cui_dpi VARCHAR,
    age INTEGER,
    gender VARCHAR,
    department VARCHAR,
    municipality VARCHAR,
    community VARCHAR,
    phone VARCHAR,
    projects_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        b.id,
        b.first_name || ' ' || b.last_name AS full_name,
        b.cui_dpi,
        b.age,
        b.gender,
        b.department,
        b.municipality,
        b.community,
        b.phone,
        COUNT(DISTINCT pb.project_id) AS projects_count
    FROM beneficiaries b
    LEFT JOIN project_beneficiaries pb ON b.id = pb.beneficiary_id
    WHERE (p_search_term IS NULL OR 
           b.first_name ILIKE '%' || p_search_term || '%' OR
           b.last_name ILIKE '%' || p_search_term || '%' OR
           b.cui_dpi ILIKE '%' || p_search_term || '%')
    AND (p_department IS NULL OR b.department = p_department)
    AND (p_municipality IS NULL OR b.municipality = p_municipality)
    AND (p_is_active IS NULL OR b.is_active = p_is_active)
    GROUP BY b.id
    ORDER BY b.last_name, b.first_name;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION sp_search_beneficiaries IS 'Busca beneficiarios por múltiples criterios';

-- =====================================================
-- MENSAJE FINAL
-- =====================================================

DO $$
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Procedimientos almacenados creados exitosamente!';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'PROCEDIMIENTOS DISPONIBLES:';
    RAISE NOTICE '';
    RAISE NOTICE 'PROYECTOS:';
    RAISE NOTICE '  - sp_update_project_progress(project_id)';
    RAISE NOTICE '  - sp_get_project_summary(project_id)';
    RAISE NOTICE '  - sp_create_project_with_phases(...)';
    RAISE NOTICE '';
    RAISE NOTICE 'BENEFICIARIOS:';
    RAISE NOTICE '  - sp_create_complete_beneficiary(...)';
    RAISE NOTICE '  - sp_get_beneficiary_profile(beneficiary_id)';
    RAISE NOTICE '  - sp_search_beneficiaries(...)';
    RAISE NOTICE '';
    RAISE NOTICE 'EVIDENCIAS:';
    RAISE NOTICE '  - sp_create_project_evidence(...)';
    RAISE NOTICE '  - sp_create_phase_evidence(...)';
    RAISE NOTICE '  - sp_get_project_evidences(project_id)';
    RAISE NOTICE '';
    RAISE NOTICE 'EJECUCIÓN PRESUPUESTARIA:';
    RAISE NOTICE '  - sp_create_project_invoice(...)';
    RAISE NOTICE '  - sp_create_phase_invoice(...)';
    RAISE NOTICE '  - sp_approve_invoice(invoice_id, approved_by)';
    RAISE NOTICE '  - sp_mark_invoice_paid(...)';
    RAISE NOTICE '  - sp_get_project_budget_summary(project_id)';
    RAISE NOTICE '  - sp_get_phase_budget_summary(phase_id)';
    RAISE NOTICE '';
    RAISE NOTICE 'REPORTES:';
    RAISE NOTICE '  - sp_get_system_statistics()';
    RAISE NOTICE '========================================';
END $$;